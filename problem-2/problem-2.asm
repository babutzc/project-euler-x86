;============================================
;   Each new term in the Fibonacci sequence is generated by adding the previous two terms. By starting with 1 and 2, the first 10 terms will be:
;   1, 2, 3, 5, 8, 13, 21, 34, 55, 89, ...
;   By considering the terms in the Fibonacci sequence whose values do not exceed four million, find the sum of the even-valued terms.
;
;   EAX  used for  value 1
;   EBX used for value 2
;   ECX used for counter
;   EBX is used for saving old value
;   EDI used for div
;   ESI is used to store the sum of the total of even fibbonaci sequence


;Makefile
;all: main
; main-object.o:  projecteuler.asm  
;         nasm -f elf32 -F stabs  -o main-object.o projecteuler.asm
; main: main-object.o
;         gcc -m32 main-object.o -o main

;===========================================
print:
    ; push ebp to stack to restore later 
    push ebp
    ; set ESP to EBP, so stack pointer goes up
    mov ebp, esp
    ; push the sum of all chars to the stack
    push esi
    ;push the format to the stack 
    push dword format
    ; call printf fucking, pops the formats and the sum of all 
    call printf
    ; restore the stack 
    mov esp, ebp
    ;place old value into the ebp 
    pop ebp
    ;return 
    ret

quit:
    ;move value 0 in ebx
    mov ebx, 0
    ;move value 1 in eax for sys_exit
    mov eax, 1
    ;call kernel to execute sys_exit with value 0
    int 80h
    ;return
    ret

section .data
    ;Format data %u means unsigned int
    format: db "Answer is: %u", 0AH, 0H
section .text

    ;define global main
    global main
    ; provide name printf
    extern printf

main:
    ;place 1 in eax as value 1 starting value fibbo sequence
    mov eax, 1
    ;place 2 in ebx as value 2 starting value fibbo sequence
    mov ebx, 2
    ;set counter to 10 to get 10 fibbo numbers
    mov ecx, 0
    ;set edx to zero as place holder for old value fibbo sequence
    mov edx, 0
    ;place 2 in edi for division
    mov edi, 2
    ;reset esi to store the sum of all even fibbo numbers
    mov esi, 0
    ;skip the sum label (we dont want to that at the moment) and go to the looper
    jmp looper

sum:
    ; add the even value to the esi register
    add esi, ebx 
    ; fix old values into edx, as we cleared it for division in looper
    pop edx
    ;fix old values into eax as we cleare it for divison in looper
    pop eax
    ; jmp to the next label
    jmp next

looper:
    ;increase the counter with 1, this checks how many times it should loop
    inc ecx
    ;push eax to the stack, as we need to prep it for division
    push eax
    ;push edx to the stack, as we need to clear the register for  divison
    push edx
    ; clear eax and edx with 0, as those registers are used with divsion
    xor eax, eax 
    xor edx, edx 
    ;place the fibbonaci value into eax, as the edx and eax are concatenated into 64bit register
    mov eax, ebx 
    ; divise it with EDI, meaning it will be EDX:EAX:EDI 
    div edi 
    ; DIV place the remainder in EDX, if the value is equal it does not contain a rest value
    cmp edx, 0
    ;if EDX equals to zero, jump to the sum label
    je sum
    ;Restore EDX to the original value  
    pop edx
    ; Restore EAX to the original value
    pop eax

next:
    ; placce the value eax into the edx, so we can add it in the next instruction
    mov edx, eax
    ;add edx and ebx
    add edx, ebx
    ;place ebx into eax to contain the previous value
    mov eax, ebx
    ;place edx into ebx so the ebx contains the current value 
    mov ebx, edx
    ; F(34) = 5702887, so we only have to loop 33 times to get the answer 
    cmp ecx, 33
    ;If does not equal 33 repeat the program
    jne looper

continue:
    ;push ALL registers to the stack, to make sure the old values are safed as printf could mess up the registers
    pushad
    ;call the print function
    call print
    ;restore ALL old values from the stack
    popad
    ;Exit the program
    call quit





